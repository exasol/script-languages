#!/usr/bin/env perl

use strict;
use warnings;

use Cwd qw(realpath);
use Data::Dumper;
use Digest::MD5;
use English;
use File::Basename;
use File::Find;
use File::Path qw(mkpath);
use File::Spec::Functions qw(file_name_is_absolute catfile rel2abs abs2rel);
use FindBin;
use Getopt::Long;
use Net::Ping;
use POSIX qw(strftime);
use Storable qw(store retrieve);

#
# prototypes
#

sub _test_get_internals ();
sub add_info_to_log ();
sub add_library_to_database ($$$$);
sub arch_of_bigarchive ($);
sub arch_of_binary ($);
sub arch_of_universal ($);
sub ask ($$);
sub ask_pw ($$);
sub check_for_incomplete_driver_manager_libs();
sub check_installed_packages ($);
sub check_md5 ($$);
sub check_package ();
sub check_package_integrity($);
sub check_system_version ($);
sub classify_dmgr_by_other_libs ($%);
sub classify_dmgr_libs ($;$);
sub classify_dmgr_libs_by_name ($);
sub classify_dmgr_libs_by_name_and_member ($);
sub classify_dmgr_libs_by_pkgmgr ($);
sub create_odbcconfig ();
sub create_odbcini ();
sub create_support_pkg ();
sub create_wrapper_script ();
sub debug ($);
sub error ($);
sub exec_support_cmd ($$;$);
sub fatal ($);
sub find_known_libs ();
sub find_libs_in_dir ($;$);
sub find_libs_in_known_dirs();
sub find_libs_in_ldconfig ();
sub get_aix_version ();
sub get_connections();
sub get_darwin_version ();
sub get_hpux_version ();
sub get_freebsd_version ();
sub get_libs ($);
sub get_linux_description ();
sub get_linux_version ();
sub get_linux_version_by_description ($);
sub get_pids ($);
sub get_process_info;
sub get_sunos_version ();
sub guess_driver ();
sub help ();
sub hostlist($$);
sub ia_do_not_overwrite ();
sub ia_goodbye ();
sub ia_guess ();
sub ia_info ($);
sub ia_search_for_driver_manager_libs ();
sub ia_test_connection (); 
sub ia_test_odbc_connections ();
sub ia_welcome ();
sub identify_binformat ($);
sub identify_processor ($);
sub identify_system ();
sub info ($);
sub init_consts ();
sub init_program ();
sub internal_error ($);
sub ldd_of_driver_libs ();
sub ldd_of_odbc_connection ();
sub load_database ();
sub logfile_only ($);
sub main ();
sub md5 ($);
sub msg;
sub notice ($);
sub parse_options ();
sub ping ($$);
sub print_config_summary ();
sub print_next_steps ();
sub reformat ($$);
sub save_database ();
sub search_for_driver_manager_libs ();
sub search_path (@);
sub short_help ();
sub some_hosts_are_reachable($);
sub strip_error_location (@);
sub system_is_32bit_only ($$);
sub system_is_64bit_only ($$);
sub test_connection ();
sub test_odbc_connections ();
sub type_by_dsn ($);
sub uniq (@);
sub version ();
sub warning ($);
sub write_internals ($);
sub write_odbcini ();
sub write_wrapper_script ();

#
# main
#

my (%system, %config, $database);

sub main () {
    local $SIG{__WARN__} = sub { internal_error($_[0]); };
    init_program();

    if ($main::opts{mode} eq 'config') {
        check_package();
        search_for_driver_manager_libs();
        check_for_incomplete_driver_manager_libs();
        test_connection();
        create_odbcconfig();
        test_odbc_connections();
        print_config_summary();
        save_database();
        create_support_pkg();
        print_next_steps();
    } elsif ($main::opts{mode} eq 'guess') {
        load_database();
        guess_driver();
    } elsif ($main::opts{mode} eq 'interactive') {
        ia_welcome();
        check_package();
        ia_search_for_driver_manager_libs();
        ia_test_connection();
        ia_do_not_overwrite();
        ia_test_odbc_connections();
        print_config_summary();
        save_database();
        create_support_pkg();
        ia_guess();
        ia_goodbye();
    }
    exit ($main::errors > 0) ? 1 : 0;
}

#
# initialisation
#

sub init_program () {
    $ENV{LC_ALL} = "C";
    $main::errors = 0;
    identify_system();
    init_consts();
    parse_options();
    add_info_to_log();
    version();
}

sub identify_system () {
    $system{uname} = `uname`;
    chomp $system{uname};

    $system{processor} = identify_processor($system{uname});
    $system{binformat} = identify_binformat($system{uname});
    $system{only32} = system_is_32bit_only($system{uname}, $system{processor});
    $system{only64} = system_is_64bit_only($system{uname}, $system{processor});

    if ($system{uname} eq 'AIX') {
        ($system{version}, $system{description}) = get_aix_version();
    } elsif ($system{uname} eq 'Darwin') {
        ($system{version}, $system{description}) = get_darwin_version();
    } elsif ($system{uname} eq 'HP-UX') {
        ($system{version}, $system{description}) = get_hpux_version();
    } elsif ($system{uname} eq 'Linux') {
        ($system{version}, $system{description}) = get_linux_version();
    } elsif ($system{uname} eq 'SunOS') {
        ($system{version}, $system{description}) = get_sunos_version();
    } elsif ($system{uname} eq 'FreeBSD') {
        ($system{version}, $system{description}) = get_freebsd_version();
    }

    $system{pkgmgr} = {};
    foreach my $pmgr (qw(rpm dpkg)) {
        foreach my $path (File::Spec::Functions::path()) {
            if (-x "$path/$pmgr") {
                $system{pkgmgr}->{$pmgr} = "$path/$pmgr";
                last;
            }
        }
    }
}

sub identify_processor ($) {
    my $uname = shift;
    my $processor;
    if ($uname eq 'HP-UX' or $uname eq 'Linux') {
        $processor = `uname -m`;
    } else {
        $processor = `uname -p`;
    }
    chomp $processor;
    return $processor;
}

sub identify_binformat ($) {
    my $uname = shift;
    my $binformat = 'ELF';
    if ($uname eq 'AIX') {
        $binformat = 'XCOFF';
    } elsif ($uname eq 'Darwin') {
        $binformat = 'MACH-O';
    }
    return $binformat;
}

sub system_is_32bit_only ($$) {
    my $uname = shift;
    my $processor = shift;
    if ($uname eq 'AIX') {
        my $out = `getconf KERNEL_BITMODE 2>&1`;
        return ($out =~ /32/);
    } elsif ($uname eq 'Darwin') {
        return 0;
    } elsif ($uname eq 'HP-UX') {
        my $out = `getconf KERNEL_BITS 2>&1`;
        return ($out =~ /32/);
    } elsif ($uname eq 'Linux') {
        return ($processor =~ /i\d86/);
    } elsif ($uname eq 'SunOS') {
        my $out = `isainfo -v 2>&1`;
        return ($out !~ /64-bit/);
    } elsif ($uname eq 'FreeBSD') {
        return ($processor =~ /i\d86/);
    }
}

sub system_is_64bit_only ($$) {
    my $uname = shift;
    my $processor = shift;
    if ($uname eq 'FreeBSD') {
        # 32 bit not supported at the moment
        return 1;
    }
}

sub get_aix_version () {
    my $version = "AIX " . `uname -v`;
    chomp $version;
    $version .= '.' . `uname -r`;
    chomp $version;
    return $version, $version
}

sub get_darwin_version () {
    my $version = "MacOS";
    my $description = `sw_vers -productName`;
    chomp $description;
    $description .= ' ' . `sw_vers -productVersion`;
    chomp $description;
    if (`sw_vers -productVersion` =~ /^(\d+\.\d+)/) {
        $version = "MacOS $1";
    }
    return $version, $description;
}

sub get_hpux_version () {
    my $version = "HP-UX";
    my $description = 'HP-UX ' . `uname -r`;
    chomp $description;
    if ($description =~ /(11\.\d+)/) {
        $version = "HP-UX $1";
    }
    return $version, $description;
}

sub get_linux_version () {
    my $description = get_linux_description();
    my $version = get_linux_version_by_description($description);
    return $version, $description;
}

sub get_linux_description () {
    my $description;
    my $out = `lsb_release -d 2>/dev/null`;
    if ($out =~ /:\s*(.*)/) {
        $description = $1;
    } else {
        foreach my $rel (qw(redhat-release centos-release SuSE-release debian_version)) {
            my $path = "/etc/$rel";
            if (-e $path) {
                $description = `grep -v '^#' $path`;
                chomp $description;
                $description = "Debian GNU/Linux $description" if $rel =~ /debian/;
                last;
            }
        }
    }
    if (!defined $description or not $description) { 
        $description = 'Generic Linux';
    }
    return $description;
}

sub get_linux_version_by_description ($) {
    my $description = shift; 
    my $version = 'Linux';
    if ($description =~ /(CentOS|Debian)\D*(\d+)(\.\d|\s)/) {
        $version = "$1 $2";
    } elsif ($description =~ /(Red Hat Enterprise Linux)\D*(\d+)(\.\d|\s)/) {
        $version = "RHEL $2";
    } elsif ($description =~ /(Ubuntu|openSUSE)\D*(\d+\.\d+)/) {
        $version = "$1 $2";
    } elsif ($description =~ /SUSE Linux Enterprise ([SD])(?:erver|esktop) (\d+)/) {
        $version = "SLE$1 $2";
    }
    return $version;
}

sub get_sunos_version () {
    my $release = `uname -r`;
    $release =~ /\.(.*)/;
    my $version = "Solaris $1";
    return $version, $version;
}

sub get_freebsd_version () {
    my $description = `uname -sr`;
    $description =~ /^([^-]*)-/;
    my $version = "$1";
    return $version, $description
}

sub init_consts () {
    # init consts for default opts, package dependecies, system specifics etc.
    $main::program = basename($PROGRAM_NAME);
    $main::version = '6.0.8 (rev. gbc/exasol/R6.0.8:8365)';

    %config = (
        paths => {
            version => "$FindBin::Bin/VERSION.txt",
            checksums => "$FindBin::Bin/MD5SUMS",
            basedir => $FindBin::Bin,
            libdir => "$FindBin::Bin/lib",
            bindir => "$FindBin::Bin/bin",
            database => "$FindBin::Bin/.$main::program.db",
            support => "$FindBin::Bin/support",
        },
        names => {
            uo2212 => {
                32 => 'unixODBC up to 2.2.12 (32bit)',
                64 => 'unixODBC up to 2.2.12 (64bit)',
            },
            uo2214lv1 => {
                32 => 'unixODBC 2.2.14 or 2.3.0, libversion 1 (32bit)',
                64 => 'unixODBC 2.2.14 or 2.3.0, libversion 1 (64bit)',
            },
            uo2214lv2 => {
                32 => 'unixODBC 2.2.14 or later, libversion 2 (32bit)',
                64 => 'unixODBC 2.2.14 or later, libversion 2 (64bit)',
            },
            dd => {
                32 => 'DataDirect (32bit)',
                64 => 'DataDirect (64bit)',
            },
            io418sys => {
                32 => 'iODBC "4.18.0" (system lib) (32bit)',
                64 => 'iODBC "4.18.0" (system lib) (64bit)',
            },
            io352fw => {
                32 => 'iODBC 3.52 (framework) (32bit)',
                64 => 'iODBC 3.52 (framework) (64bit)',
            },
            io3529 => {
                64 => 'iODBC 3.52.9 (64bit)',
            }
        },
        libdir => {
            'AIX' => { 32 => 'aix6/32', 64 => 'aix6/64' },
            'Darwin' => { 32 => 'darwin/i386', 64 => 'darwin/x86_64' },
            'FreeBSD' => { 32 => 'freebsd10/i386', 64 => 'freebsd10/amd64'},
            'HP-UX' => { 32 => 'hpux/hpux32', 64 => 'hpux/hpux64' },
            'Linux' => { 32 => 'linux/x86', 64 => 'linux/x86_64' },
            'SunOS' => { 32 => 'sunos/x86', 64 => 'sunos/x86_64' },
        },
        LIBPATH_name => {
            'AIX' => 'LIBPATH',
            'Darwin' => 'DYLD_LIBRARY_PATH',
            'FreeBSD' => 'LD_LIBRARY_PATH',
            'HP-UX' => 'LD_LIBRARY_PATH',
            'Linux' => 'LD_LIBRARY_PATH',
            'SunOS' => 'LD_LIBRARY_PATH',
        },
        pkg => {
            'CentOS 6' => 'Linux/Unix',
            'CentOS 7' => 'Linux/Unix',
            'Debian 8' => 'Linux/Unix',
            'FreeBSD 10.3' => 'Linux/Unix',
            'FreeBSD 11.0' => 'Linux/Unix',
            'MacOS 10.11' => 'Linux/Unix',
            'MacOS 10.12' => 'Linux/Unix',
            'RHEL 6' => 'Linux/Unix',
            'RHEL 7' => 'Linux/Unix',
            'SLED 12' => 'Linux/Unix',
            'SLES 11' => 'Linux/Unix',
            'SLES 12' => 'Linux/Unix',
            'Ubuntu 14.04' => 'Linux/Unix',
            'Ubuntu 16.04' => 'Linux/Unix',
            'openSUSE 13.2' => 'Linux/Unix',
            'openSUSE 42.1' => 'Linux/Unix',
            'openSUSE 42.2' => 'Linux/Unix',
        },
        driver => {
            'AIX' => {
                uo2212 => "libexaodbc-uo2212.so",
                uo2214lv2 => "libexaodbc-uo2214lv2.so",
                dd => "libexaodbc-dd.so",
            },
            'Darwin' => {
                io352fw => "libexaodbc-io352fw.dylib",
                io418sys => "libexaodbc-io418sys.dylib",
            },
            'FreeBSD' => {
                uo2214lv2 => "libexaodbc-uo2214lv2.so",
                io3529 => "libexaodbc-io3529.so",
            },
            'HP-UX' => {
                uo2212 => "libexaodbc-uo2212.so",
                uo2214lv1 => "libexaodbc-uo2214lv1.so",
                uo2214lv2 => "libexaodbc-uo2214lv2.so",
                dd => "libexaodbc-dd.so",
            },
            'Linux' => {
                uo2212 => "libexaodbc-uo2212.so",
                uo2214lv1 => "libexaodbc-uo2214lv1.so",
                uo2214lv2 => "libexaodbc-uo2214lv2.so",
                dd => "libexaodbc-dd.so",
            },
            'SunOS' => {
                uo2212 => "libexaodbc-uo2212.so",
                uo2214lv1 => "libexaodbc-uo2214lv1.so",
                uo2214lv2 => "libexaodbc-uo2214lv2.so",
                dd => "libexaodbc-dd.so",
            },
        },
        needs_origin_dir_in_path => {
            'AIX' => 1,
            'Darwin' => 0,
            'FreeBSD' => 1,
            'HP-UX' => 0,
            'Linux' => 0,
            'SunOS' => 0,
        },
        packages => {
            'MacOS 10.12' => {
                optional => [
                    {
                        name => 'iODBC Framework',
                        file => '/Library/Frameworks/iODBCinst.framework/Versions/3.52/iODBCinst',
                        help => "The iODBC 3.52 Framework is missing\n"
                                . "http://www.iodbc.org/downloads/iODBC/iodbc-sdk-3.52.7-macosx-10.5.dmg",
                    },
                ],
            },
            'FreeBSD 11.0' => {
                required => [
                    {
                        name => 'unixODBC',
                        file => '/usr/local/lib/libodbc.so',
                        help => 'pkg install unixODBC',
                    },
                    {
                        name => 'libiodbc',
                        file => '/usr/local/lib/libiodbc.so',
                        help => 'pkg install libiodbc',
                    },
                    {
                        name => 'gmp',
                        file => '/usr/local/lib/libgmp.so',
                        help => 'pkg install gmp',
                    },
                    {
                        name => 'libiconv',
                        file => '/usr/local/lib/libiconv.so.2',
                        help => 'pkg install libiconv',
                    },
                ],
            },
            'CentOS 6' => {
                optional => [
                    {
                        name => 'unixODBC',
                        file => '/usr/bin/isql',
                        help => 'yum install unixODBC',
                    },
                ],
                optional_32on64 => [
                    {
                        name => 'libstdc++ 32bit',
                        cmd  => 'rpm --quiet -q libstdc++.i686',
                        help => "Mandatory for 32bit applications; install with:\n" .
                                'yum install libstdc++.i686',
                    },
                ],
            },
            'Debian 8' => {
                optional => [
                    {
                        name => 'unixODBC',
                        file => '/usr/bin/isql',
                        help => 'apt-get install unixodbc',
                    },
                ],
                optional_32on64 => [
                    {
                        name => 'libstdc++ 32bit',
                        cmd  => 'dpkg -l libstdc++6:i386',
                        help => "Mandatory for 32bit applications; install with:\n" .
                                'apt-get install libstdc++6:i386',
                    },
                ],
            },
            'SLES 11' => {
                optional => [
                    {
                        name => 'unixODBC',
                        cmd => 'rpm --quiet -q unixODBC',
                        help => 'zypper install unixODBC',
                    },
                ],
                optional_32on64 => [
                    {
                        name => 'libstdc++ 32bit',
                        cmd  => 'rpm --quiet -q libstdc++6-32bit',
                        help => "Mandatory for 32bit applications; install with:\n" .
                                'zypper install libstdc++6-32bit',
                    },
                    {
                        name => 'glibc-locale 32bit',
                        cmd  => 'rpm --quiet -q glibc-locale-32bit',
                        help => "Mandatory for 32bit applications; install with:\n" .
                                'zypper install glibc-locale-32bit',
                    },
                ],
            }, 
        },
        system_libs => {
            'MacOS 10.12' => [
                '/usr/lib/libiodbc.dylib',
                '/usr/lib/libiodbcinst.dylib',
                '/Library/Frameworks/iODBC.framework/iODBC',
                '/Library/Frameworks/iODBCinst.framework/iODBCinst',
            ],
        },
        system_lib_dirs => {
            # bug in SLES/SLED 10: /etc/ld.so.cache is not updated properly
            'SLES 11' => [
                '/lib',
                '/lib64',
                '/usr/lib',
                '/usr/lib64',
            ],
        },
    );
    $config{packages}{'CentOS 7'} = $config{packages}{'CentOS 6'};
    $config{packages}{'FreeBSD 10.3'} = $config{packages}{'FreeBSD 11.0'};
    $config{packages}{'MacOS 10.11'} = $config{packages}{'MacOS 10.12'};
    $config{packages}{'RHEL 6'} = $config{packages}{'CentOS 6'};
    $config{packages}{'RHEL 7'} = $config{packages}{'CentOS 6'};
    $config{packages}{'SLED 12'} = $config{packages}{'SLES 11'};
    $config{packages}{'SLES 12'} = $config{packages}{'SLES 11'};
    $config{packages}{'Ubuntu 14.04'} = $config{packages}{'Debian 8'};
    $config{packages}{'Ubuntu 16.04'} = $config{packages}{'Debian 8'};
    $config{packages}{'openSUSE 13.2'} = $config{packages}{'SLES 11'};
    $config{packages}{'openSUSE 42.1'} = $config{packages}{'SLES 11'};
    $config{packages}{'openSUSE 42.2'} = $config{packages}{'SLES 11'};

    $config{system_libs}{'MacOS 10.11'} = $config{system_libs}{'MacOS 10.12'};

    if ($system{uname} eq 'SunOS' and $system{processor} eq 'sparc') {
        $config{libdir}{SunOS} = { 32 => 'sunos/sparc32', 64 => 'sunos/sparc64' };
    }

    %main::default_opts = (
        help => 0,
        version => 0,
        verbosity => 4,
        force => 0,
        mode => 'interactive',
        searchdirs => ['/usr/local'],
        unixodbc2212_searchdirs => [],
        unixodbc2214_searchdirs => [],
        pids => [],
        logfile => "$config{paths}{basedir}/$main::program.log",
        wrapper => "$config{paths}{basedir}/exaodbc_wrapper",
        host => '',
        port => 8563,
        user => 'sys',
        password => 'exasol',
        odbcini => $system{uname} eq 'Darwin'
            ? "$ENV{HOME}/Library/ODBC/odbc.ini" : "$ENV{HOME}/.odbc.ini",
        odbclog => "$config{paths}{basedir}/exaodbc.log",
    );

    $database = {};
}

sub parse_options () {
    my %opts;
    Getopt::Long::Configure(qw(no_ignore_case bundling));
    { 
        local $SIG{__WARN__} = sub { print "$_[0]"; short_help(); exit 2; };
        GetOptions(\%opts,
            "help|?",
            "version",
            "verbosity=i",
            "force",
            "logfile=s",
            "wrapper=s",
            "mode=s",
            "searchdirs=s@",
            "unixodbc2214_searchdirs=s@",
            "unixodbc2212_searchdirs=s@",
            "pids=i@",
            "host=s",
            "user=s",
            "password=s",
            "odbclog=s",
            "odbcini=s",
        );
        foreach my $opt (keys %main::default_opts) {
            $main::opts{$opt} = $opts{$opt} || $main::default_opts{$opt};
        }
        if ($main::opts{help}) {
            help() and exit 0;
        } elsif ($main::opts{version}) {
            version() and exit 0;
        }
        if ($main::opts{mode} !~ /^(config|guess|interactive)$/) {
            warn "Unknown mode: $main::opts{mode}\n";
        }
        if ($main::opts{mode} eq 'config') {
            if (!$main::opts{host}) {
                warn "Option --host is mandatory for --mode='config'\n";
            }
        }
    }
}

sub short_help () {
    my $help = qq/
        Usage: $main::program --host=HOST
                        [--user=USER] [--password=PASSWORD]
                        [--odbcini=FILE [--force]] [--odbclog=FILE]
                        [--searchdir=DIR]...
                        [--unixodbc2212_searchdir=DIR]...
                        [--unixodbc2214_searchdir=DIR]...
                        [--verbosity=LEVEL] [--logfile=FILE]
               $main::program --mode=guess [--pid=PID]...
               $main::program --version
               $main::program --help
       /;
    $help =~ s/^ {8}//gm;
    print $help, "\n";
}

sub help () {
    version();
    short_help();
    my $help = qq/
        Options:
            --mode {interactive|config|guess}
                        operation mode (default: $main::default_opts{mode}); see below
                        for a detailed description. 

        Config mode options:
            --host HOST name or ip address of EXASolution server; lists and ranges
                        are also possible; port is optional (defaults to $main::default_opts{port});
                        examples: 10.0.0.1..8:1234; the host option has no default.
            --user USER user name (default: $main::default_opts{user}).
            --password PASSWORD
                        password (default: $main::default_opts{password}).
                        WARNING: passwords in the command line can be observed by other
                        users.
            --odbcini FILE
                        path to ODBC ini file (default: $main::default_opts{odbcini}).
            --force     overwrite existing ODBC ini file.
            --odbclog FILE
                        EXASolution ODBC driver logfile; logging has to be eneabled in
                        the ODBC ini file (default: $main::default_opts{odbclog}).

            --searchdir DIR
            --unixodbc2212_searchdir DIR
            --unixodbc2214_searchdir DIR
                        search DIR for driver manager libraries and autodetect the
                        owning driver manager. Unfortunately, it is not possible to
                        reliable destinguish between unixODBC 2.2.12 and 2.2.14 in all
                        cases. The later two options force a decision. All options can
                        be given more than once. The default is @{[join(', ', @{$main::default_opts{searchdirs}})]} for
                        --searchdir and nothing for the other two.

        Guess mode options:
            --pid PID   restrict guessing to process PID (default: all processes owned
                        by current user).

        General options:
            --logfile FILE
                        location of $main::program\'s logfile
                        (default: $main::default_opts{logfile}).
            --verbosity LEVEL
                        verbosity (default: $main::default_opts{verbosity}).

            --help      this help.
            --version   version.


        Modes:
            interactive step by step configuration. Config and guess mode options can
                        be used to change defaults.
            config      create an ODBC ini file and an execution wrapper script;
                        autodetect driver managers; test connectivity to EXASolution.
            guess       guess the correct DSN for running applications (owned by the
                        current user). In order to work, applications must at least
                        load the driver manager libraries.
    /;
    $help =~ s/^ {8}//gm;
    print $help, "\n";
}

sub version () {
    print "$main::program $main::version\n";
    print 'Copyright (c) 2018 EXASOL AG' . "\n";
    print "\n";
}

sub add_info_to_log () {
    logfile_only("");
    logfile_only("$main::program $main::version");
    logfile_only("");
    logfile_only("system family: $system{uname}");
    logfile_only("system version: $system{version}");
    logfile_only("system description: $system{description}");
    logfile_only("processor type: $system{processor}");
    my @isets;
    $isets[++$#isets] = "32bit" if not $system{only64}; 
    $isets[++$#isets] = "64bit" if not $system{only32}; 
    logfile_only("instruction sets: " . join(", ", @isets));
    logfile_only("options: ");
    foreach my $x (sort keys %main::opts) {
        if (ref($main::opts{$x}) eq 'ARRAY') {
            logfile_only("  $x => [" . join(", ", @{$main::opts{$x}}) . "]");
        } else {
            if ($x eq 'password' and $main::opts{$x} ne $main::default_opts{$x}) {
                logfile_only("  $x => " . ("*" x length($main::opts{$x})) );
            } else {
                logfile_only("  $x => $main::opts{$x}");
            }
        }
    }
}

#
# check package integrity
#

sub check_package () {
    notice("check package");
    check_system_version($config{paths}->{version})
        or fatal("unsupported system");
    check_package_integrity($config{paths}->{checksums})
        or fatal("integrity check failed; see README.txt for details");
    notice("check for required packages");
    check_installed_packages($config{packages}{$system{version}}{required})
        or fatal("required packages are missing");
    notice("check for optional packages");
    check_installed_packages($config{packages}{$system{version}}{optional})
        or warning("optional packages are missing");
    if (not $system{only32} and not $system{only64}) { 
        notice("check for optional packages (32bit)");
        check_installed_packages($config{packages}{$system{version}}{optional_32on64})
            or warning("optional packages (32bit) are missing");
    }
}

sub check_system_version ($) {
    my $path = shift;
    my $fd;

    my $expected;
    if (exists $config{pkg}->{$system{version}}) {
        $expected = $config{pkg}->{$system{version}};
    } else {
        if ($system{uname} eq 'Linux') {
            $expected = 'Linux';
            warning("system $system{description} is not supported");
        } else {
            error("system $system{description} is not supported");
            return 0;
        }
    }

    open($fd, $path) or fatal("$path: $OS_ERROR");
    my $version = readline($fd);
    close($fd);
    chomp $version;
    info("package: $version");
    if ($version =~ $expected) {
        debug("package matches system");
    } else {
        error('wrong package for this system: expected: EXASolution ODBC for ' . "$expected, got: $version");
        return 0;
    }
    return 1;
}

sub check_package_integrity($) {
    my $checksums = shift;
    my @result;
    my $fd;
    open($fd, $checksums) or fatal("$checksums: $OS_ERROR");
    while (<$fd>) {
        /^(\S+)\s+(.*)/;
        my $digest = $1;
        my $path = $2;
        if (not file_name_is_absolute($path)) {
            $path = catfile(dirname($checksums), $path);
        }
        if (not check_md5($path, $digest)) {
            push(@result, $2);
        }
    }
    close $fd;
    foreach my $x (@result) {
        error("checksum missmatch for file: $x");
    }
    return not @result;
}

sub check_md5 ($$) {
    my ($path, $digest) = @_;
    return md5($path) eq $digest;
}

sub md5 ($) {
    my $path = shift;
    my $fd;
    my $md5 = Digest::MD5->new;
    open($fd, $path) or error("$path: $OS_ERROR") and return '';
    $md5->addfile($fd);
    close $fd;
    return $md5->hexdigest;
}

sub check_installed_packages ($) {
    my $hashref = shift;
    my $errors = 0;
    if (defined $hashref) {
        foreach my $pkg (@{$hashref}) {
            if (defined $pkg->{file} and not -e $pkg->{file}) {
                debug("test file: $pkg->{file}");
                $errors += 1;
                warning("package $pkg->{name} is missing");
                info("$pkg->{help}");
            } elsif (defined $pkg->{cmd} and not system("$pkg->{cmd} >/dev/null 2>/dev/null") == 0) {
                debug("test command: $pkg->{cmd}"); 
                $errors += 1;
                warning("package $pkg->{name} is missing");
                info("$pkg->{help}");
            }
        }
    }
    if (not $errors) {
        debug("no missing packages");
    }
    return not $errors;
}

#
# create ODBC ini file and driver directories
#

sub create_odbcconfig () {
    write_odbcini();
    write_wrapper_script();
}

sub write_odbcini () {
    my $path = $main::opts{odbcini};
    notice("create ODBC ini file: $path");
    if (-e $path and not $main::opts{force}) {
        info("use --force to overwrite existing ODBC ini file");
        fatal("path exists: $path");
    }
    if (not -e dirname($path)) {
        mkpath(dirname($path));
    }
    my $fd;
    open($fd, ">", $path) or fatal("$path: $OS_ERROR");
    chmod(0600, "$path");
    print $fd create_odbcini();
    close $fd;
}

sub create_odbcini () {
    my $result;
    my $datasources = "[ODBC Data Sources]\n";

    foreach my $dmgr (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}->{$dmgr}}) {
            next if $arch eq '64' && $system{only32};
            next if $arch eq '32' && $system{only64};
            $datasources .= "exasolution-${dmgr}_$arch = $config{names}{$dmgr}{$arch}\n";
            my $exahost = $main::opts{host};
            $exahost .= ":$main::opts{port}" unless $exahost =~ /:\d+(\.\.\d+)?$/;

            my $driver = $config{paths}{libdir} . "/" .
                $config{libdir}{$system{uname}}{$arch} . "/" .
                $config{driver}{$system{uname}}{$dmgr};
            foreach my $dbg ("", "-debug") {
                $result .= qq(
                    [exasolution-${dmgr}_$arch$dbg]
                    DRIVER = $driver
                    EXAHOST = $exahost
                    EXAUID = $main::opts{user}
                    EXAPWD = $main::opts{password});
                $result .= qq(
                    EXALOGFILE = $main::opts{odbclog}
                    LOGMODE = verbose) if $dbg;
                $result .= qq(
                    DRIVERUNICODETYPE = 2
                    ; Do not insert white space before '=':
                    IANAAppCodePage= 106) if $dmgr eq 'dd';
                $result .= "\n";
            }
        }
    }
    $result .= "\n";
    $result =~ s/^[ \t]+//gm;
    $result = $datasources . "\n" . $result;
    return $result;
}

sub write_wrapper_script () {
    my $path = $main::opts{wrapper};
    notice("create wrapper script: $path");
    my $fd;
    open($fd, ">", $path) or fatal("$path: $OS_ERROR");
    print $fd create_wrapper_script();
    close $fd;
    chmod(0755, $path);
}

sub create_wrapper_script () {
    my $LD = $config{LIBPATH_name}->{$system{uname}};
    my $scriptlet = "";
    my @dsns;
    foreach my $dmgr (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}->{$dmgr}}) {
            foreach my $dbg ("", "-debug") {
                my $dsn = "exasolution-${dmgr}_$arch$dbg";
                push(@dsns, $dsn);
                my $libdir = $config{libdir}{$system{uname}}{$arch};
                my @ldpathdirs = values(%{$database->{driver_manager}->{$dmgr}->{$arch}->{libs}});
                push(@ldpathdirs, $config{paths}{libdir} . '/' . $config{libdir}{$system{uname}}{$arch} . '/dummy.so')
                    if $config{needs_origin_dir_in_path}{$system{uname}};
                my $ldpath = search_path(@ldpathdirs);
                my $type = type_by_dsn($dsn);
                my $tb = "$libdir/odbc_conn_test-$type";
                $scriptlet .= qq/\t$dsn)
                    \t\tsearch_path="$ldpath"
                    \t\ttest_binary="$tb"
                    \t;;
                /;
            }
        }
    }
    my $dsns = join(", ", @dsns);
    my $script = qq{#!/bin/sh
    
        if [ \$# -lt 1 ]; then
        \techo "Usage:  \$0 DSN program_with_args" >&2
        \techo "        \$0 DSN" >&2
        \techo >&2
        };
        if (@dsns) {
            for my $i (0..$#dsns) {
                if ($i == 0) {
                    $script .= "\techo 'DSN:    $dsns[$i]' >&2\n";
                } else {
                    $script .= "\techo '        $dsns[$i]' >&2\n";
                }
            }
        } else {
            $script .= "\techo 'DSN:    no DSN available' >&2\n";
        }
    $script .= qq{    
        \techo >&2
        \techo "Executes a program with environment settings suiteable" >&2
        \techo "for the given DSN." >&2
        \techo "Tests the ODBC connection for DSN if no program is given." >&2
        \texit 2
        fi

        ODBCINI="$main::opts{odbcini}"
        export ODBCINI
    
        bindir="$config{paths}{bindir}"

        dsn="\$1"
        shift

        case "\$dsn" in
        $scriptlet
        \t*)
        \t\techo "\$0: unknown DSN "\$dsn"" >&2
        \t\texit 2
        \t;;
        esac
        
        if [ "\$search_path" != "" ]; then
        \tif [ "\$$LD" = "" ]; then
        \t\t$LD="\$search_path"
        \telse
        \t\t$LD="\$$LD:\$search_path"
        \tfi
        \texport $LD
        fi

        if [ \$# -lt 1 ]; then
        \texec "\$bindir/\$test_binary" "\$dsn"
        else
        \texec "\$@"
        fi

    };

    $script =~ s/^[ ]+//gm;
    1 while $script =~ s/^(\t*)\t/$1    /gm;
    return $script;
}

sub type_by_dsn ($) {
    my $dsn = shift;
    my $type = "";
    if ($dsn =~ /uo2212/ or $dsn =~ /uo2214lv1/) {
        $type = "lv1";
    } elsif ($dsn =~ /uo2214lv2/) {
        $type = "lv2";
    } elsif ($dsn =~ /io418sys/) {
        $type = "sys";
    } elsif ($dsn =~ /io352fw/) {
        $type = "fw";
    } elsif ($dsn =~ /io3529/) {
        $type = "io";
    } elsif ($dsn =~ /dd/) {
        $type = "dd";
    } else {
        internal_error("unrecognized DSN: $dsn");
    }
    return $type;
}

sub search_path (@) {
    my @dirs;
    foreach my $path (@_) {
        push(@dirs, dirname($path));
    }
    return join(':', uniq(@dirs));
}

#
# interactive mode
#

sub ia_welcome () {
    my $msg = 
        "Welcome to the EXASolution ODBC configuration program!
        
        To run this program non-interactively, start it with --mode=config or
        --mode=guess.
        
        Start it with --help to get the list of available options; they can be used
        to change the defaults in interactive mode, too.

        Please make shure that the perl-Data-Dumper package is installed.
    ";
    $msg =~ s/^[ \t]+//gm; 
    ia_info($msg);
    exit if ask("continue", "y") !~ /^[yY]$/;
}

sub ia_search_for_driver_manager_libs () {
    my $msg = 
        "If you use a self-compiled ODBC driver manager (or one provided by a
        3rd-party package) that is not installed in the usual system directory,
        add the directory here.

        Multiple directories can be seperated by spaces. Do not add system
        directories like /usr/lib.";
    $msg =~ s/^[ \t]+//gm;
    ia_info($msg);
    while (1) {
        my $sd = join(' ', @{$main::opts{searchdirs}});
        $sd = ask("additional searchdirs", "$sd");
        $main::opts{searchdirs} = [split(/ +/, $sd)];

        search_for_driver_manager_libs();
        check_for_incomplete_driver_manager_libs();
        last if ask("search again (y/n)?", "n") =~ /^[nN]$/; 
    }
}

sub ia_test_connection () { 
    my $msg = 
        "Give the connection string for EXASolution. Hostnames, IP addresses and
        IP ranges are all possible. The port is optional.
        Example: 10.0.0.1..5:1234"; 
    $msg =~ s/^[ \t]+//gm;
    ia_info($msg);
    while (1) {
        $main::opts{host} = ask("connection", "$main::opts{host}");
        last if test_connection();
    }
}

sub ia_test_odbc_connections () {
    my $msg = "To test ODBC connectivity we need a valid EXASolution user.";
    ia_info($msg);
    while (1) {
        $main::opts{user} = ask("user", "$main::opts{user}");
        $main::opts{password} = ask_pw("password", "$main::opts{password}");
        create_odbcconfig();
        last if test_odbc_connections();
        last if ask("try again (y/n)", "y") !~ /^[yY]$/;
    }
}

sub ia_do_not_overwrite () {
    return if $main::opts{force};
    while (-e $main::opts{odbcini}) {
        ia_info("The file $main::opts{odbcini} exists.");
        last if ask("overwrite (y/n)", "n") =~ /^[yY]$/;
        $main::opts{odbcini} = ask("path to odbc.ini file", "$main::opts{odbcini}");
    }
    $main::opts{force} = 1; 
}

sub ia_guess () {
    my $msg =
        "Guess the correct DSN for running applications.

        * Applications: open the select data source dialog (or something similar).

        * Scripting languages: load the appropriate ODBC module.

        Connecting to any data source is not necessary.

        Scan only processes with given pids (separated by spaces) or use '0'
        to scan all processes of the current user. (Scanning processes owned by
        other users require root access.)
        ";
    $msg =~ s/^[ \t]+//gm;
    ia_info($msg);
    my $default = "";
    my $pids = "";
    while (1) {
        $default = join(" ", @{$main::opts{pids}});
        $default = "0" if $default eq "";
        $pids = ask("pids", "$default");
        $pids = "" if $pids eq "0";
        $main::opts{pids} = [split(/ +/, $pids)];
        guess_driver();
        last if ask("scan again (y/n)", "n") !~ /^[yY]$/;
    }
}

sub ia_goodbye () {
    my $msg = 
        "Configuration completed.

        If your application does not work with the correct DSN, your system
        may require setting additional environment variables.

        For how to do this, have a look at the wrapper script
        $main::opts{wrapper}.

        In case of persisting problems, please contact support and include
        the generated support.tar file.
    ";
    $msg =~ s/^[ \t]+//gm; 
    ia_info($msg);
}

sub ia_info ($) {
    print "\n";
    for my $line (split /\n/, shift) {
        print "# ", $line, "\n";
    }
}

sub ask ($$) {
    my $prompt = shift;
    my $default = shift;
    if (!defined $default) {
        print "\n? $prompt ";
    } else {
        print "\n? $prompt [$default]: ";
    }
    my $line = readline(*STDIN);
    chomp($line);
    $line = $default if not $line and defined $default;
    print "\n";
    return $line;
}

sub ask_pw ($$) {
    my $prompt = shift;
    my $default = shift;
    my $show_default = $main::default_opts{password};
    $show_default = "*" x length($default) if $default ne $show_default;
    print "\n? $prompt [$show_default]: ";
    system('stty', '-echo');
    my $line = readline(*STDIN);
    system('stty', 'echo');
    print "\n\n";
    chomp($line);
    $line = $default if not $line;
    return $line;
}
    
#
# test connection
#

sub test_connection () {
    notice("test network connection");
    my $connections = get_connections();
    return some_hosts_are_reachable($connections);
}

sub get_connections() {
    my $connections = [];
    foreach my $conn (hostlist($main::opts{host}, $main::opts{port})) {
        push(@{$connections}, {host => $conn->[0], port => $conn->[1]});
    }
    $database->{connections} = $connections;
    return $connections;
}

sub some_hosts_are_reachable($) {
    my $connections = shift;
    my $reachable = 0;
    foreach my $conn (@{$connections}) {
        my ($host, $port);
        $host = $conn->{host};
        $port = $conn->{port};
        info("tcp-connect $host:$port");
        if (not ping($host, $port)) {
            error("host $host:$port is not reachable");
            $conn->{test} = 'failed';
        } else {
            $conn->{test} = 'ok';
            $reachable = 1
        }
    }
    return $reachable;
}

sub hostlist($$) {
    my $connstring = shift;
    my $defaultport = shift;
    my @connections = ();

    # connstring is of the form:
    # port = num | num + ".." num
    # hostrange = string | string + num + ".." + num + string
    #                    | ip
    #                    | num + "." + num + "." + num + "." + num + ".." + num
    # hostset = hostrange | hostrange + "," + hostset
    # connstring = hostset | hostset + ":" + port
    #                      | hostset + ":" + port + "," + connstring
    #
    # example: foo1..10,bar1..5:1234,baz
    #
    # The correct port for a host is the next port to the right or the
    # defaultport. So foo1, foo2,...foo10 have port 1234, baz has not.

    sub valid_port($) {
        my $port = shift;
        if ($port !~ /^\d+(\.\.\d+)?$/) {
            error("invalid port format: $port");
            return 0;
        }
        return 1;
    }
    sub valid_hostrange($) {
        my $hostrange = shift;
        return 0 if $hostrange =~ /\.\.\./;
        return 0 if $hostrange =~ /\.\..*\.\./;
        if ($hostrange =~ /(\d+)\.\.(\d+)/) {
            return $1 <= $2;
        }
        return 0 if $hostrange =~ /\.\./;
        return 1;
    }
    sub expand_range($) {
        my $range = shift;
        my @hosts = ();
        if ($range =~ /^(.*\D|)(\d+)\.\.(\d+)(.*)/) {
            if ($2 > $3) {
                error("invalid host or port range: $range");
            }
            for (my $i = $2; $i <= $3; $i++) {
                push(@hosts, $1 . $i . $4);
            }
        } else {
            push(@hosts, $range)
        }
        return @hosts;
    }


    return unless valid_port($defaultport);

    my $ports = $defaultport;
    foreach my $connstr (reverse split(',', $connstring)) {
        my ($conn, $p) = split(':', $connstr);
        if (defined $p) {
            $ports = $p;
            return unless valid_port($ports);
        }
        if (not valid_hostrange($conn)) {
            error("invalid host range: $conn");
            return;
        }
        foreach my $host (reverse expand_range($conn)) {
            foreach my $port (reverse expand_range($ports)) {
                push(@connections, [$host, $port]);
            }
        }
    }
    return reverse @connections;
}

sub ping ($$) {
    my ($host, $port) = @_;
    my $p = Net::Ping->new('tcp');
    $p->service_check(1);
    $p->{port_num} = $port;
    return $p->ping($host);
}

sub test_odbc_connections () {
    my $some_are_reachable = 0;
    foreach my $dm (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}{$dm}}) {
            next if $arch eq '64' && $system{only32};
            next if $arch eq '32' && $system{only64};
            info("odbc-connect exasolution-${dm}_$arch");
            my $test = "$main::opts{wrapper} exasolution-${dm}_$arch-debug";
            my $output = `$test 2>&1`;
            debug($output);
            if ($? eq 0) {
                $database->{driver_manager}{$dm}{$arch}{test} = 'ok';
                $some_are_reachable = 1;
            } else {
                $output =~ s/.*\nconnecting\.\.\.\n(.*)\.\.\.failed/$1/s;
                error($output);
                $database->{driver_manager}{$dm}{$arch}{test} = 'failed';
            }
        }
    }
    return $some_are_reachable;
}

#
# search for driver manager libraries
#

sub search_for_driver_manager_libs () {
    notice("search for driver manager libraries");
    my @libs;
    my %libs;

    push(@libs, find_libs_in_ldconfig());
    push(@libs, find_known_libs());
    push(@libs, find_libs_in_known_dirs());
    foreach my $dir (@{$main::opts{searchdirs}}) {
        push(@libs, find_libs_in_dir($dir));
    }
    @libs = uniq(map({ realpath($_); } @libs));
    foreach my $lib (@libs) {
        $libs{$lib}{dm} = classify_dmgr_libs($lib);
    }

    @libs = ();
    foreach my $dir (@{$main::opts{unixodbc2212_searchdirs}}) {
        push(@libs, find_libs_in_dir($dir));
    }
    @libs = uniq(map({ realpath($_); } @libs));
    foreach my $lib (@libs) {
        $libs{$lib}{dm} = classify_dmgr_libs($lib, 'uo2212');
    }

    @libs = ();
    foreach my $dir (@{$main::opts{unixodbc2214_searchdirs}}) {
        push(@libs, find_libs_in_dir($dir));
    }
    @libs = uniq(map({ realpath($_); } @libs));
    foreach my $lib (@libs) {
        $libs{$lib}{dm} = classify_dmgr_libs($lib, 'uo2214lv1');
    }
    foreach my $lib (keys %libs) {
        $libs{$lib}{md5} = md5($lib);
    }
    foreach my $lib (keys %libs) {
        if ($libs{$lib}{dm} eq 'uo') {
            $libs{$lib}{dm} = classify_dmgr_by_other_libs($lib, %libs);
        }
    }
    foreach my $lib (sort keys %libs) {
        if ($libs{$lib}) {
            my $arch = arch_of_binary($lib);
            my $dm = $libs{$lib}{dm};
            my $md5 = $libs{$lib}{md5};
            info("found: $lib => $dm");
            if ($dm eq 'uo') {
                warning("unable to detect driver manager for $lib");
                warning("either unixODBC <= 2.2.12");
                warning("or unixODBC >= 2.2.14 libversion 1");
                warning("use --unixodbc2212_searchdir, --unixodbc2214_searchdir to force a version");
            } else {
                if (defined $config{driver}{$system{uname}}{$dm}) {
                    add_library_to_database($lib, $dm, $arch, $md5);
                } else {
                    info("driver manager $dm not supported by this package");
                }
            }
        } else {
            debug("ignored: $lib");
        }
    }
}

sub find_libs_in_ldconfig () {
    my @libs;
    if ($system{uname} eq 'Linux') {
        debug('searching registered system libraries (ldconfig)');
        my $fd;
        open($fd, '/sbin/ldconfig -p 2>/dev/null |') or return @libs;
        while(<$fd>) {
            if ($_ =~ /=>\s+(.*\/libodbc(inst)?\.so.*)/) {
                push(@libs, $1);
            }
        }
        close $fd;
    } elsif ($system{uname} eq 'FreeBSD') {
        debug('searching registered system libraries (ldconfig)');
        my $fd;
        open($fd, '/sbin/ldconfig -r 2>/dev/null |') or return @libs;
        while(<$fd>) {
            if ($_ =~ /=>\s+(.*\/libi?odbc(inst)?\.so.*)/) {
                push(@libs, $1);
            }
        }
        close $fd;
    }
    return @libs;
}

sub find_known_libs () {
    my @libs;
    if (defined $config{system_libs}{$system{version}}) {
        debug("searching known system libraries");
        for my $lib (@{$config{system_libs}{$system{version}}}) {
            push(@libs, $lib) if -e $lib;
        }
    }
    return @libs;
}

sub find_libs_in_known_dirs() {
    my @libs;
    if (defined $config{system_lib_dirs}{$system{version}}) {
        debug("searching known system directories");
        for my $dir (@{$config{system_lib_dirs}{$system{version}}}) {
            push(@libs, find_libs_in_dir($dir, 1));
        }
    }
    return @libs;
}
    
sub find_libs_in_dir ($;$) {
    my $dir = rel2abs(shift);
    my $nowarn = shift;
    my @libs;
    my $ext = $system{uname} eq 'AIX' ? 'a' : 'so';
    debug("searching: $dir");
    if (-e $dir) {
        local $SIG{__WARN__} = sub { warning(strip_error_location(@_)); };
        find(
            {
                wanted => sub {
                    push(@libs, $File::Find::name) if
                        -f $File::Find::name
                        and $File::Find::name =~ /(.*\/libodbc(inst)?\.$ext.*)/;
                },
                follow_fast => 1,
                follow_skip => 2,
            },
            $dir
        );
    } else {
        if ($nowarn) {
            info("search dir: $dir: No such file or directory");
        } else {
            warning("search dir: $dir: No such file or directory");
        }
    }
    return @libs;
}

sub classify_dmgr_libs ($;$) {
    my $path = shift;
    my $hint = shift;
    my $dmgr;
    if ($system{uname} eq 'AIX') {
        $dmgr = classify_dmgr_libs_by_name_and_member($path);
    } else {
        $dmgr = classify_dmgr_libs_by_name($path);
    }

    if ($dmgr eq 'uo') {
        $dmgr = classify_dmgr_libs_by_pkgmgr($path) || $dmgr;
        $dmgr = 'uo2214lv1' if $dmgr eq 'uo2214';
    }

    if ($dmgr eq 'uo' and $hint) {
        $dmgr = $hint;
    }
    return $dmgr;
}

sub classify_dmgr_libs_by_name ($) {
    my $path = shift;
    my $file = basename($path);
    if ($file =~ /^libodbc(inst)?\.so$/) {
        return 'dd';
    } elsif ($file =~ /^libodbc(inst)?\.so\.1(\.0\.0)?$/) {
        return 'uo';
    } elsif ($file =~ /^libodbc(inst)?\.so\.2(\.0\.0)?$/) {
        return 'uo2214lv2';
    } elsif ($path =~ m'/usr/lib/libiodbc(inst)?\.2\.1\.18\.dylib$') {
        return 'io418sys';
    } elsif ($path =~ m'/Library/Frameworks/(iODBC(inst)?)\.framework(/.*)?/\1$') {
        return 'io352fw';
    } elsif ($path =~ m'/usr/local/lib/libiodbc(inst)?.so') {
        return 'io3529';
    }
    return '';
}

sub classify_dmgr_libs_by_name_and_member ($) {
    my $path = shift;
    my $file = basename($path);
    my $fd;
    if ($file !~ /^libodbc(inst)?\.a$/) {
        return '';
    }
    open($fd, "ar -t -Xany $path |") or return "";
    while (<$fd>) {
        return 'dd' if (/^odbc(inst)?\.so$/);
        return 'uo2214lv2' if (/^libodbc(inst)?\.so\.2$/);
        return 'uo' if (/^libodbc(inst)?\.so\.1$/);
        if ($INPUT_LINE_NUMBER > 100) {
            error("library $path looks broken");
            error("consult README_unixODBC.txt for details");
            last;
        }
    }
    close $fd;
    return '';
}

sub classify_dmgr_libs_by_pkgmgr ($) {
    my $path = shift;
    my $fd;
    if (exists $system{pkgmgr}->{rpm}) {
        open($fd, "rpm -qf '$path' 2>/dev/null |");
        if ($fd) {
            my $line = readline($fd);
            close $fd;
            if (defined $line) {
                if ($line =~ /unixodbc.*(2\.2\.14|2\.3)/i) {
                    return 'uo2214';
                } elsif ($line =~ /unixodbc.*2\.2\.1[123]/i) {
                    return 'uo2212';
                }
            }
        }
    }
    if (exists $system{pkgmgr}->{dpkg}) {
        open($fd, "dpkg -S '$path' 2>/dev/null |");
        if ($fd) {
            my $line = readline($fd);
            close $fd;
            if (defined $line) {
                chomp $line;
                $line =~ /^([^:]+)/;
                open($fd, "dpkg -s '$1' 2>/dev/null |");
                while (<$fd>) {
                    if (/^Version:\s*(.*(2\.2\.14|2\.3.\d+))/) {
                        close($fd);
                        return 'uo2214';
                    } elsif (/^Version:\s*(.*2\.2\.1[123])/) {
                        close($fd);
                        return 'uo2212';
                    }
                }
                close($fd);
            }
        }
    }
    return '';
}

sub classify_dmgr_by_other_libs ($%) {
    my ($lib, %libs) = @_;

    my %dmgrs;
    my $md5 = $libs{$lib}{md5};
    if ($libs{$lib}{dm} ne 'uo') {
        return $libs{$lib}{dm};
    }
    foreach my $l (keys %libs) {
        if ($libs{$l}{md5} eq $md5) {
            $dmgrs{$libs{$l}{dm}} = 1;
        }
    }
    delete $dmgrs{uo};
    if (scalar keys %dmgrs == 1) {
        return (keys %dmgrs)[0];
    } else {
        return 'uo';
    }
}

sub check_for_incomplete_driver_manager_libs () {
    notice("check for incomplete driver manager libraries");
    foreach my $dm (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}{$dm}}) {
            next if $arch eq '64' && $system{only32};
            next if $arch eq '32' && $system{only64};
            my $pathlibodbc = $database->{driver_manager}{$dm}{$arch}{libs}{libodbc};
            my $pathlibodbcinst = $database->{driver_manager}{$dm}{$arch}{libs}{libodbcinst};
            if (not defined $pathlibodbc) {
                warning("libodbcinst exists, but libodbc is missing");
                info("$pathlibodbcinst");
                info("install libodbc before proceeding");
            } elsif (not defined $pathlibodbcinst) { 
                warning("libodbc exists, but libodbcinst is missing");
                info("$pathlibodbc");
                info("install libodbcinst before proceeding");
            }
        }
    }
}


#
# config drivers
#

sub print_config_summary () {
    notice("config summary");
    my $dsn;
    info("available driver managers:");
    foreach my $dmgr (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (qw(32 64)) {
            next if $arch eq '64' && $system{only32};
            next if $arch eq '32' && $system{only64};
            if (defined $database->{driver_manager}{$dmgr}{$arch}) {
                info("* $config{names}{$dmgr}{$arch}");
                info("  => DSN=exasolution-${dmgr}_$arch");
                if (defined $database->{driver_manager}{$dmgr}{$arch}{test}) {
                    info("  connection test: $database->{driver_manager}{$dmgr}{$arch}{test}");
                } else {
                    info("  connection test: skipped");
                }
                $dsn += 1;
            }
        }
    }
    if ($dsn) {
        info('the wrapper script sets up the neccessarry environment');
    } else {
        warning("no usable driver manager found");
    }
    info("if an expected driver manager is missing, install missing packages");
    info("or re-run this program with different --searchdir options");
}

sub print_next_steps () {
    notice("next steps");
    info("- start your application");
    info("- check what driver manager your application needs with");
    info("  $main::program --mode=guess");
    info("in order to work, your application needs to connect to a driver manager,");
    info("but not to an actual data source");
}

#
# persistent storage
#

sub save_database () {
    debug("saving mappings (library => driver manager) to file");
    store($database, $config{paths}->{database})
        or error("saving database failed");
}

sub load_database () {
    debug("loading mappings (library => driver manager) from file");
    if (-e $config{paths}->{database}) {
        $database = retrieve($config{paths}->{database})
            or fatal("unable to load database file");
    } else {
        if ($main::opts{mode} !~ /^(config|interactive)$/) {
            fatal("database file does not exists; run with --mode=config first");
        }
    }
}

sub add_library_to_database ($$$$) {
    my ($lib, $dmgr, $arch, $md5) = @_;

    if ($arch eq '32_64') {
        add_library_to_database($lib, $dmgr, '32', $md5);
        add_library_to_database($lib, $dmgr, '64', $md5);
        return;
    }


    my $type;
    if ($lib =~ /libi?(odbc(?:inst)?)/i) {
        $type = "lib$1";
    } elsif ($lib =~ /\/iODBC$/) {
        $type = "libodbc";
    } elsif ($lib =~ /\/iODBCinst$/) {
        $type = "libodbcinst";
    } else {
        internal_error("try to add unclassified library: $lib");
        return;
    }

    if (exists $database->{driver_manager}{$dmgr}{$arch}{libs}{$type}) {
        my $oldlib = $database->{driver_manager}{$dmgr}{$arch}{libs}{$type};
        if ($oldlib ne $lib) {
            if ($database->{library}{$oldlib}{md5} eq $md5) {
                info("identical $type libraries for driver manager $dmgr (${arch}bit):");
                info("  1: $oldlib");
                info("  2: $lib");
                info("ignoring (2)");
            } else {
                error("conflicting $type libraries for driver manager $dmgr (${arch}bit):");
                error("  1: $oldlib");
                error("  2: $lib");
                error("ignoring (2)");
            }
        }
    } else {
        $database->{driver_manager}{$dmgr}{$arch}{libs}{$type} = $lib;
        $database->{library}{$lib}{driver_manager} = $dmgr;
        $database->{library}{$lib}{md5} = $md5;
        if (defined $database->{library}{$lib}{arch}) {
            my @archs = @{$database->{library}{$lib}{arch}};
            push(@archs, $arch);
            $database->{library}{$lib}{arch} = [uniq(@archs)];
        } else {
            $database->{library}{$lib}{arch} = [$arch];
        }
    }
}

#
# support
#

sub create_support_pkg () {
    notice("create a support package");
    info("please add support.tar to any EXASOL support request");
    my $path = $config{paths}{support};
    system("rm -rf $path");
    mkdir($path);
    mkdir("$path/env");
    mkdir("$path/exaodbc");
    mkdir("$path/ldd");
    mkdir("$path/pkgs");
    mkdir("$path/system");


    exec_support_cmd("date", "system/date");
    exec_support_cmd("uname -a", "system/uname_-a");
    exec_support_cmd("env", "env/env", 1);
    exec_support_cmd("locale -a", "env/locale_-a");
    exec_support_cmd("R --version", "pkgs/R_--version");
    exec_support_cmd("perl -V", "pkgs/perl_-V");
    exec_support_cmd("perl -v", "pkgs/perl_-v");
    exec_support_cmd("php -V", "pkgs/php_-V");
    exec_support_cmd("php -v", "pkgs/php_-v");
    exec_support_cmd("python -V", "pkgs/python_-V");
    exec_support_cmd("ruby -v", "pkgs/ruby_-v");

    if ($system{uname} eq 'AIX') {
        exec_support_cmd("rpm -qa", "pkgs/rpm_-qa", 1);
        exec_support_cmd("lslpp -al", "system/lslpp_-al");
    } elsif ($system{uname} eq 'Darwin') {
        exec_support_cmd("pkginfo -l", "pkgs/pkginfo_-l");
    } elsif ($system{uname} eq 'HP-UX') {
        exec_support_cmd("/usr/sbin/swlist -R", "pkgs/swlist_-R");
    } elsif ($system{uname} eq 'Linux') {
        exec_support_cmd("rpm -qa", "pkgs/rpm_-qa", 1);
        exec_support_cmd("dpkg -l", "pkgs/dpkg_-l");
        exec_support_cmd("/sbin/ldconfig -p", "system/ldconfig_-p");
        exec_support_cmd("/usr/sbin/sestatus", "system/sestatus");
    } elsif ($system{uname} eq 'SunOS') {
        exec_support_cmd("pkgutil --pkgs", "pkgs/pkgutil_--pkgs");
    } elsif ($system{uname} eq 'FreeBSD') {
        exec_support_cmd("/usr/sbin/pkg info -a", "pkgs/pkg_info_-a");
        exec_support_cmd("/sbin/ldconfig -r", "system/ldconfig_-r");
    }
    if ($system{uname} eq 'Darwin') {
        exec_support_cmd("vm_stat -c1 1", "system/vm_stat_-c1_1");
    } else {
        exec_support_cmd("vmstat 1 1", "system/vmstat_1_1");
    }

    write_internals("$path/exaodbc/$main::program.dump");

    system("cp $config{paths}{version} $path/exaodbc");
    system("cp $config{paths}{checksums} $path/exaodbc");
    for my $file (qw/redhat-release centos-release SuSE-release debian_version lsb-release os-release/) {
        system("cp /etc/$file $path/system") if -e "/etc/$file";
    }
    system("cp $main::opts{wrapper} $path/exaodbc");
    system("cp $main::opts{logfile} $path/exaodbc");
    system("sed -e 's/EXAPWD.*/EXAPWD = <removed for privacy>/' $main::opts{odbcini} > $path/exaodbc/odbc.ini");
    system("cp $main::opts{odbclog} $path/exaodbc/exaodbc.log 2>/dev/null");

    ldd_of_driver_libs();
    ldd_of_odbc_connection();

    system("cd $config{paths}{basedir} && tar -cf $path.tar support");
    system("rm -rf $path");
}

sub exec_support_cmd ($$;$) {
    my $cmd = shift;
    my $output = shift;
    my $sort = "";
    $sort = "| LC_ALL=C sort" if shift;

    my $path = "$config{paths}{support}/$output";
    my $rc = system("$cmd 2>$path.2 $sort >$path.1");
}

sub ldd_of_driver_libs () {
    foreach my $dmgr (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}->{$dmgr}}) {
            next if $arch eq '64' && $system{only32};
            next if $arch eq '32' && $system{only64};

            my $driver = $config{paths}{libdir} . "/" .
                $config{libdir}{$system{uname}}{$arch} . "/" .
                $config{driver}{$system{uname}}{$dmgr};

            my $dsn = "exasolution-${dmgr}_$arch";
            my $type = type_by_dsn($dsn);
            my $ldd = "$main::opts{wrapper} $dsn ldd $driver";
            exec_support_cmd($ldd, "ldd/ldd_driver-$dmgr-$arch");
        }
    }
}

sub ldd_of_odbc_connection () {
    foreach my $dmgr (sort keys %{$database->{driver_manager}}) {
        foreach my $arch (sort keys %{$database->{driver_manager}->{$dmgr}}) {
            my $dsn = "exasolution-${dmgr}_$arch";
            my $bindir = $config{paths}{bindir} . "/" . 
                $config{libdir}{$system{uname}}{$arch};
            my $type = type_by_dsn($dsn);
            my $ldd = "$main::opts{wrapper} $dsn ldd $bindir/odbc_conn_test-$type";
            exec_support_cmd($ldd, "ldd/ldd_odbc_conn_test-$type-$dmgr-$arch");
        }
    }
}

sub write_internals ($) {
    $Data::Dumper::Indent = 1;
    $Data::Dumper::Terse = 1;
    $Data::Dumper::Sortkeys = 1;

    my $output = shift;
    my $fd;
    open($fd, ">", $output) or error("$output: $OS_ERROR");
    print $fd Dumper({
        database => $database,
        config => \%config,
        'system' => \%system,
        });
    close($fd);
}

#
# guess driver of running applications
#

sub guess_driver () {
    notice("guess driver of running applications");
    my $first = 1;
    foreach my $pid (get_pids($main::opts{pids})) {
        my ($cmd, $arch) = get_process_info($pid);
        next if not defined $cmd; # process exited
        my @libs = get_libs($pid);
        if (not grep /odbc/i, @libs) {
            next;
        }
        info("-" x 60) if not $first; $first = 0;
        info("pid: $pid");
        info("cmd: $cmd");
        info("arch: $arch");
        foreach my $lib (@libs) {
            if ($lib =~ /\/(libodbc|libiodbc|iodbc)/i) {
                info("lib: $lib");
            } else {
                debug("lib: $lib");
            }
        }
        my %dsn;
        foreach my $lib (@libs) {
            next if not -e $lib;
            my $lpath = realpath($lib);
            if (exists $database->{library}{$lpath}) {
                my $dsn = "exasolution-$database->{library}{$lpath}{driver_manager}_$arch";
                if (not defined $dsn{$dsn}) {
                    info("dsn: $dsn");
                    $dsn{$dsn} = 1;
                }
            }
        }
        if (keys %dsn > 1) {
            error("process $pid: incompatible driver managers used");
        }
    }
}

sub get_pids ($) {
    my $requested = shift;
    my @pids;
    my @result;
    my $cmd = "ps -ef";
    $cmd = "ps aux" if $system{uname} =~ 'Darwin|FreeBSD';
    my $fd;
    open($fd, "$cmd 2>/dev/null |") or fatal("unable to get process list");
    while (<$fd>) {
        if (/^\s*$ENV{USER}\s+(\S*)/) {
            push(@pids, $1);
        }
    }
    close $fd;
    if (not $requested or not @{$requested}) {
        @result =  @pids;
    } else {
        my %requested;
        foreach my $pid (@{$requested}) {
            $requested{$pid} = 1;
        }
        foreach my $pid (@pids) {
            push(@result, $pid) if $requested{$pid};
        }
    }
    @result = sort {$a <=> $b} @result;
    return @result;
}

sub get_process_info {
    my $pid = shift;
    my $cmd = 'unknown';
    my $arch = 'unknown';
    my $fd;

    if ($system{uname} eq 'AIX') {
        $arch = arch_of_binary("/proc/$pid/object/a.out");
        open($fd, "procmap $pid 2>/dev/null |");
        while (<$fd>) {
            if ($_ =~ /^\d+\s*:\s*(\S.*)/) {
                $cmd = $1;
                last;
            }
        }
        close($fd);
    } elsif ($system{uname} eq 'Darwin') {
        if ($system{version} =~ /^(MacOS 10.1[012])$/) {
            warning("guessing might not work on $1");
        }
        open MAP, "vmmap -w $pid </dev/null 2>/dev/null |";
        while(<MAP>) {
            if (/(32|64)-bit process/) {
                $arch = $1;
            }
            if (/Virtual Memory Map of process .* \((.+)\)/) {
                $cmd = $1;
            }
            last if $INPUT_LINE_NUMBER == 2;
        }
        close MAP;
    } elsif ($system{uname} eq 'Linux') {
        $cmd = readlink("/proc/$pid/exe") or return undef, undef;
        $arch = arch_of_binary($cmd);
    } elsif ($system{uname} eq 'HP-UX') {
        open($fd, "/usr/ccs/bin/pldd $pid 2>/dev/null |");
        my $line = readline($fd);
        close($fd);
        defined $line or return undef, undef;
        $line =~ /.*:\s*(\S+)(.*)/ or return undef, undef;
        $cmd = "$1$2";
        $arch = arch_of_binary($1);
    } elsif ($system{uname} eq 'FreeBSD') {
        open($fd, "procstat -bh $pid 2>/dev/null |");
        my $line = readline($fd);
        close($fd);
        defined $line or return undef, undef;
        $line =~ /(\/\S+)/ or return undef, undef;
        my $binary = $1; 
        open($fd, "procstat -ch $pid 2>/dev/null |");
        $line = readline($fd);
        close($fd);
        defined $line or return undef, undef;
        $line =~ /^\s*(\d+)\s+(\S+)\s+(\S+)(.*)/ or return undef, undef;
        $cmd = "$binary$4";
        $arch = arch_of_binary($binary);
    } elsif ($system{uname} eq 'SunOS') {
        $cmd = readlink("/proc/$pid/path/a.out") or return undef, undef;
        $arch = arch_of_binary("/proc/$pid/object/a.out");
    }
    return $cmd, $arch;
}

sub arch_of_binary ($) {
    # returns '32', '64', '32_64', or 'unknown'
    my $path = shift;
    my $fd;
    my $magic;
    open($fd, $path) or return 'unknown';
    read($fd, $magic, 7);
    close $fd;
    if ($system{binformat} eq 'XCOFF') {
        return '32' if unpack('n', $magic) == 0x01df;
        return '64' if unpack('n', $magic) == 0x01f7;
        return arch_of_bigarchive($path) if substr($magic, 0, 7) eq '<bigaf>';
    } elsif ($system{binformat} eq 'ELF') {
        return '32' if substr($magic, 0, 5) eq pack("CA3C", 127, "ELF", 1);
        return '64' if substr($magic, 0, 5) eq pack("CA3C", 127, "ELF", 2);
    } elsif ($system{binformat} eq 'MACH-O') {
        return '32' if unpack('N', $magic) == 0xcefaedfe;
        return '64' if unpack('N', $magic) == 0xcffaedfe;
        return arch_of_universal($path) if unpack('N', $magic) == 0xcafebabe;
    }
    return 'unknown';
}

sub arch_of_bigarchive ($) {
    my $path = shift;
    my $fd;
    my @arch;
    open($fd, "ar -t -X32 '$path' |");
    push(@arch, '32') if readline($fd);
    close $fd;
    open($fd, "ar -t -X64 '$path' |");
    push(@arch, '64') if readline($fd);
    close $fd;
    return (join('_', @arch) or 'unknown');
}

sub arch_of_universal ($) {
    my $path = shift;
    my @arch;
    my $lipo = `file '$path'`;
    push(@arch, '32') if $lipo =~ /\(for architecture i386\)/;
    push(@arch, '64') if $lipo =~ /\(for architecture x86_64\)/;
    return (join('_', @arch) or 'unknown');
}

sub get_libs ($) {
    my $pid = shift;
    my %libs;
    my $fd;
    if ($system{uname} eq 'AIX') {
        open($fd, "procldd $pid 2>/dev/null |");
        while (<$fd>) {
            next if /^\s*\d+\s*:/;
            chomp;
            $libs{$_} = 1;
        }
        close $fd;
    } elsif ($system{uname} eq 'Darwin') {
        open($fd, "vmmap -w $pid 2>/dev/null |");
        while(<$fd>) {
            last if /==== Legend/;
            if (/(\S+)$/) {
                $libs{$1} = 1;
            }
        }
        close $fd;
    } elsif ($system{uname} eq 'HP-UX') {
        open($fd, "/usr/ccs/bin/pldd $pid 2>/dev/null |");
        while (<$fd>) {
            next if /^\s*\d+\s*:/;
            chomp;
            $libs{$_} = 1;
        }
        close $fd;
    } elsif ($system{uname} eq 'Linux') {
        open($fd, "cat /proc/$pid/maps 2>/dev/null |");
        while (<$fd>) {
            if (/\s([^[\s]\S+)$/) {
                $libs{$1} = 1;
            }
        }
        close $fd;
    } elsif ($system{uname} eq 'FreeBSD') {
        open($fd, "procstat -vh $pid 2>/dev/null |");
        while (<$fd>) {
            if (/\s(\/\S+)$/) {
                $libs{$1} = 1;
            }
        }
        close $fd;
    } elsif ($system{uname} eq 'SunOS') {
        open($fd, "pldd $pid 2>/dev/null |");
        while (<$fd>) {
            next if /^\s*\d+\s*:/;
            chomp;
            $libs{$_} = 1;
        }
        close $fd;
    }
    my @result = sort keys %libs;
    return @result;
}

#
# logging and prompting
#

sub msg {
    my $level = shift;
    my $msg = shift;
    my $verbosity = (defined $main::opts{verbosity}) ? $main::opts{verbosity} : 3;
    my %prefix = (
        -1 => 'INTERNAL ERROR (call support): ',
        0  => 'FATAL ERROR: ',
        1  => 'ERROR: ',
        2  => 'warning: ',
        3  => "* ",
        4  => '  ',
        5  => '    ',
        10 => '# ',
    );
    my $short_prefix = $prefix{$level};
    my $full_prefix = strftime("%Y-%m-%d %H:%M:%S ", localtime()) . $short_prefix;

    if ($verbosity >= $level) {
        print reformat($short_prefix, $msg);
    }
    # FIXME
    if (defined $main::opts{logfile}) {
        my $fd;
        open($fd, ">> $main::opts{logfile}") or return;
        print $fd reformat($full_prefix, $msg);
        close $fd;
    }
}

sub reformat ($$) {
    my $prefix = shift;
    my $msg = shift;
    return $prefix . join("\n$prefix", split(/\n/, $msg)) . "\n";
}

sub logfile_only ($) { msg(10, shift); }
sub debug ($) { msg(5,  shift); }
sub info ($) { msg(4, shift); }
sub notice ($) { msg(3, shift); }
sub warning ($) { msg(2, shift); }
sub error ($) { msg(1, shift); $main::errors += 1; }
sub fatal ($) { msg(0, shift); $main::errors += 1; exit 1; }
sub internal_error ($) { msg(-1, shift); $main::errors += 1; }

sub strip_error_location (@) {
    return @{[split /\n/, $_[0]]}[0];
}

#
# helpers and test hooks
#

sub uniq (@) {
    my %hash;
    foreach my $x (@_) {
        $hash{$x} = 1;
    }
    return sort keys %hash;
}

sub _test_get_internals () {
    return {
        config => \%config,
        'system' => \%system,
        database => $database,
    };
}

#
#
#

if (basename($0) eq basename(__FILE__)) {
    main();
}
1;

# vim: ts=4:sts=4:sw=4:et:ft=perl:fdm=indent
